{"version":3,"sources":["getActionFromState.tsx"],"names":["getActionFromState","state","options","normalizedConfig","createNormalizedConfigItem","payload","current","config","params","routes","length","undefined","route","initial","screen","name","key","initialRouteName","screens","type","createNormalizedConfigs","Object","entries","reduce","acc","k","v"],"mappings":"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","sourcesContent":["import type {\n  Route,\n  PartialRoute,\n  NavigationState,\n  PartialState,\n} from '@react-navigation/routers';\nimport type { PathConfig, PathConfigMap, NestedNavigateParams } from './types';\n\ntype ConfigItem = {\n  initialRouteName?: string;\n  screens?: Record<string, ConfigItem>;\n};\n\ntype Options = { initialRouteName?: string; screens: PathConfigMap };\n\ntype NavigateAction<State extends NavigationState> = {\n  type: 'NAVIGATE';\n  payload: {\n    name: string;\n    params?: NestedNavigateParams<State>;\n  };\n};\n\nexport default function getActionFromState(\n  state: PartialState<NavigationState>,\n  options?: Options\n): NavigateAction<NavigationState> | undefined {\n  // Create a normalized configs object which will be easier to use\n  const normalizedConfig = options ? createNormalizedConfigItem(options) : {};\n\n  let payload;\n  let current: PartialState<NavigationState> | undefined = state;\n  let config: ConfigItem | undefined = normalizedConfig;\n  let params: NestedNavigateParams<NavigationState> = {};\n\n  while (current) {\n    if (current.routes.length === 0) {\n      return undefined;\n    }\n\n    const route: Route<string> | PartialRoute<Route<string>> =\n      current.routes[current.routes.length - 1];\n\n    if (current.routes.length === 1) {\n      params.initial = true;\n      params.screen = route.name;\n      params.state = undefined; // Explicitly set to override existing value when merging params\n    } else if (\n      current.routes.length === 2 &&\n      current.routes[0].key === undefined &&\n      current.routes[0].name === config?.initialRouteName\n    ) {\n      params.initial = false;\n      params.screen = route.name;\n      params.state = undefined;\n    } else {\n      params.initial = undefined;\n      params.screen = undefined;\n      params.params = undefined;\n      params.state = current;\n      break;\n    }\n\n    if (route.state) {\n      params.params = { ...route.params };\n      params = params.params;\n    } else {\n      params.params = route.params;\n    }\n\n    current = route.state;\n    config = config?.screens?.[route.name];\n\n    if (!payload) {\n      payload = {\n        name: route.name,\n        params,\n      };\n    }\n  }\n\n  if (!payload) {\n    return;\n  }\n\n  // Try to construct payload for a `NAVIGATE` action from the state\n  // This lets us preserve the navigation state and not lose it\n  return {\n    type: 'NAVIGATE',\n    payload,\n  };\n}\n\nconst createNormalizedConfigItem = (config: PathConfig | string) =>\n  typeof config === 'object' && config != null\n    ? {\n        initialRouteName: config.initialRouteName,\n        screens:\n          config.screens != null\n            ? createNormalizedConfigs(config.screens)\n            : undefined,\n      }\n    : {};\n\nconst createNormalizedConfigs = (options: PathConfigMap) =>\n  Object.entries(options).reduce<Record<string, ConfigItem>>((acc, [k, v]) => {\n    acc[k] = createNormalizedConfigItem(v);\n    return acc;\n  }, {});\n"]}